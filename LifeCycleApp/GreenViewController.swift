//
//  GreenViewController.swift
//  LifeCycleViewController
//
//  Created by Debash on 07.05.2018.
//  Copyright © 2018 swiftbook.ru. All rights reserved.
//

import UIKit

class GreenViewController: UIViewController {
    
    @IBOutlet var openThirdVC: UIButton! { // Аутлет инициализируется уже после переданного свойства через prepare, но вместе с загрузкой экрана в память по факту одновременно
        didSet { // создаем обзерверы что бы получать принт когда наше свойство инициализируется
            print(openThirdVC.currentTitle ?? "")
        }
    }
    
    var someProperties: String! {
        didSet {
            print(someProperties ?? "") // передача данного свойства осуществляется в методе prepare  при переходе с одного экрана на другой
        }
        // данное свойство инициализируется до того как вью будет загружен в память, то есть до  метода viewDidLoad. аутлеты загружаются уже после
    }
    
    override func awakeFromNib() { // данный метод вызывается впервую очередь до того как инициализируются свойства класса и аутлеты
        super.awakeFromNib()
        printMessage()
        // этот метод не является частью жизненного цикла вью потому что на момент его вызова вью просто не существует, вызывается сразу после инициализации класса
        // Если вы используете кастомные ячейки в tableviewCell нам прийдется делать для них аутлеты. И как передать данные в эти ячейки если в данных классах нет метода viewDidLoad. метода  viewDidLoad в tableviewCell нет, так как сама ячейка относится к UITableViewController соответственно она зависит от супер вью своего вью контроллера и получается tableview сначала загружается в память а потом уже ячейки. В этом методе вообще можно любой элемент интерфейса переопределить как и во viewDidLoad
    
    }
    
//    override func loadView() {
    // этот метод используется для ручной инициализации вью, если вы работаете без сториборда и нам нужно настроить каким то образом вью перед тем как оно будет загруженно в память
//    }
    
    // Вызывается после загрузки View в память
    override func viewDidLoad() {
        super.viewDidLoad() // всегда при обращении к методу viewDidLoad прописываем   super.viewDidLoad()
        title = "GreenVC"
        printMessage()
        
         // вью только загружен в память! Пользователь еще не видит сам Экран!  Этот метод используется для того  что бы настроить элементы интерфейса
        
        // Переходя на второй экран вызывается данный метод. Данный метод вызывается один раз за весь жизненный цикл, так как вью контроллер не может быть загружен два раза. Так как не может быть два обьекта вью контроллера  в памяти. Поэтому когда мы делаем переход на третий экран и возвращаемся на этот экран мы видим что вызов метода больше не вызывается так как вью контролеры как висели в памяти так и висят(желтый и зеленый).Когда мы с зеленого возвращаемся на желтый экран то мы выгружаем зеленый вью и при переходе обратно на зеленый снова срабатывает метод viewDidLoad потому что мы заново загрузили его в память. желтый же экран самый первый и его невозможно выгрузить пока приложение не будет закрыто.
        
       //  - Следующим этапом идет вызов метода viewWillAppear
    }
    
    // Вызывается перед появлением вью
    override func viewWillAppear(_ animated: Bool) { // viewWillAppear -  вью сейчас появится.
        super.viewWillAppear(animated) // точно так же этот метод требует вызов у супер класса и передаем в параметр не true ни false а параметр animated
        printMessage()
        // в момент срабатывания этого метода приложение запускается и мы видим Launch Screen.
        
        /* Этот метод вызывается перед каждым появлением вью!данный метод уведомляет нас не о загрузке экрана в память а о том что вью сейчас появится!!!
         и каждый раз данный метод срабатывает при переходе на данный экран!
         В данном методе работают с настройкой элементов
         Например:
         Мы перешли на экран настроек, внесли определенные изменения.И что бы изменения отразились мы должны прописать их в данном методе.
         В методе viewDidLoad мы настраиваем элементы интерфейса раз и навсегда а здесь мы настраиваем элементы интерфейса которые должны обновляться при каждом открытии экрана.
         
        Не важно в какой последовательности реализовали данный метод вызовется после viewDidLoad
         
         НО ХОТЬ ДАННЫЙ МЕТОД И ГОВОРИТ ЧО ВЬЮ СЕЙЧАС ПОЯВИТСЯ ПОЛЬЗОВАТЕЛЬ ЕГО НЕ ВИДИТ ТАК КАК НЕОБХОДИМО ЕЩЕ ВЫЗВАТЬ МЕТОД updateViewConstraints
         САМ ПО СЕБЕ ДАНЫНЙ МЕТОД НЕ БУДЕТ ВЫЗЫВАТЬСЯ!!!
         */
    }
    
    // Вызывается при расстановке констрейнтов
    override func updateViewConstraints() {
        printMessage()
        super.updateViewConstraints() // ВЫЗЫВАЕМ МЕТОД  У СУПЕР КЛАССА УЖЕ ПОСЛЕ ПЕРЕОПРЕДЕЛЕНИЯ МЕТОДА!
        
        // ДАННЫЙ МЕТОД НЕОБХОДИМО ПЕРЕОПРЕДЕЛЯТЬ ТОЛЬКО В ТОМ СЛУЧАЕ КОГДА СЛЕДУЕТ ОПТИМИЗИРОВАТЬ СОСТОЯНИЕ КОНСТРЕЙНТОВ!
        /*
         Данный метод вызывается очень редко. Например нажали на кнопку, вышла дополнительная вьюшка. Она должна сместить элементы интерфейса, те должны ужаться или уменьшится (вообщем у них должны поменяться констрейнты). По сути эти изменения лучше выполнять на саму кнопку!
         И ЧТО БЫ ВЫЗВАТЬ ДАННЫЙ МЕТОД НУЖНО, ЧТО БЫ СИСТЕМА ПОНЯЛА В КАКОЙ МОМЕНТ НЕОБХОДИМО СОВЕРШИТЬ ИЗМЕНЕНИЯ НУЖНО ПРОПИСАТЬ МЕТОД setNeedsUpdateConstraints() ТЕМ САМЫМ МЫ ПРОСИМ СИСТЕМУ ВЫЗВАТЬ ПЕРЕОПРЕДЕЛЕННЫЙ МЕТОД updateViewConstraints()
         ПРИ ЭТОМ НЕЛЬЗЯ ВЫЗЫВАТЬ МЕТОД setNeedsUpdateConstraints() ВНУТРИ САМОГО updateViewConstraints() ТАК КАК ПРОИЗОЙДЕТ РЕКУРСИЯ!
         методы будут вызывать друг друга по кругу
         */
        // ПОЛЬЗОВАТЕЛЬ ВСЕ ЕЩЕ НЕ ВИДИТ ЭКРАН
    }
    
    // Вызывается перед расстановкой всех элементов на экране
    override func viewWillLayoutSubviews() { // - Элементы интерфейса сейчас будут расставлены
        printMessage()
         // в момент вызова этого метода становятся доступны Геометрические величины! и в это методе можно изменить размеры элементов интерфейса и их положение!
        /*
         МЕТОД ВЫЗЫВАЕТСЯ 2 РАЗА
         - ПЕРВЫЙ РАЗ В НЕМ ВСЕ ЕЩЕ ДОСТУПНЫ РАЗМЕРЫ ИЗ СТОРИБОРДА
         - А ВТОРОЙ РАЗ ЭТО РЕАЛЬНЫЕ РАЗМЕРЫ ЭЛЕМЕНТОВ ИНТЕРФЕЙСА
         Допустим как было  со светофором, там элементы интерфейса динамические и зависели от размера самого экрана вью!
         допустим на маленьком экране элементы 100:100, то при показе на экране 12 pro Max элементы будут 170:170
         И скруглять углы нужно именно здесь! Так как в методе viewDidLoad известны данные из стори борда  а не реальные размеры
         НО НЕ ЗНАЧИТ ЧТО ВСЕ СКРУГЛЕНИЯ УГЛОВ НУЖНО ДЕЛАТЬ В ДАННОМ МЕТОДЕ, МЫ ДЕЛАЕМ ТОЛЬКО В ТОМ СЛУЧАЕ ЕСЛИ РАЗМЕРЫ ЭЛЕМЕНТА ИНТЕРФЕЙСЯ ЗАВИСЯТ ОТ РАЗМЕРА САМОГО ЭКРАНА.
         если же эллементы статичны то конечно же делаем в методе viewDidLoad так как метод viewWillLayoutSubviews вызывается перед каждым Auto Layout
         А Auto Layout происходит при каждом повороте экрана из портретного в  ландшафтный и обратно
         */
    }
    
    /*
     */
    // Тут срабатывает Auto Layout (система расставляет эллементы на экране в зависимости от правил которые мы задали, а правила мы задаем при помощи консрейнтов , стеков и установки всех величин
    
    
    // Вызывается после расстановки всех элементов на экране
    override func viewDidLayoutSubviews() {
        printMessage()
        // метод такой же как  viewWillLayoutSubviews только срабатывает по факту расстановки
        /*
         В данном методе можно сохранять последние состояния каких либо элементов. например положение scrollview или выделение ячейки в tableview.
         Например: Мы поворачиваем экран на бок - у нас меняется ориентация и что бы строка которая была по нижней части экрана мы как раз эту логику закладываем в данный метод
         */
    }
    
    // Вызывается после появления вью на экране
    override func viewDidAppear(_ animated: Bool) {  // ВСЕ ЧТО ПРОИЗОЙДЕТ В ДАННОМ МЕТОДЕ БУДЕТ ВИДНО НА ГЛАЗАХ У ПОЛЬЗОВАТЕЛЯ!!!
        super.viewDidAppear(animated)
        printMessage()
        // данный метод является финальным в цепочке появления вью,в данный момент мы уже видим наш экран  и срабатывает через пару миллисекунд после показа экрана пользователю.
        //В ДАННОМ МЕТОДЕ МОЖНО ЗАПУСТИТЬ ПРОЦЕСС АНИМАЦИИ ЧЕГО ЛИБО или показа рекламы
        
        /*
         */
    
        // ВСЕ МЫ ВИДИМ ЭКРАН!
        
    }
    
    // Вызывается при изменении размеров вью
    override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
        super.viewWillTransition(to: size, with: coordinator) // передаем данные из параметров, параметр size возвращает новый размер вью при каждом повороте а coordinator может использоваться для управления анимацией при переходе вью из одного состояния в другое.
        print(size.height) //просматриваем высоту экрана через свойство size
        
        // Вызывается когда view  меняет свой размер (допустим при повороте экрана меняется высота, ширина)
        /*
         Таким образом мы можем определять положение устройства в зависимости от размера экрана! if размер высоты меньше размера ширины  значит мы в ландшафтной ориентации иначе в портретной
         */
    }
    
    // Вызывается перед скрытием вью
    override func viewWillDisappear(_ animated: Bool) { // данный метод вызывается перед тем как вью будет скрыто
        super.viewWillDisappear(animated) // так же вызываем метод из супер класса
        printMessage()
        /*
         В данном методе обычно:
         - убирают first responder status (это когда курсор мигает в текстовом поле),
         - если какие то действия происходят то ставят их на паузу
         - можно почистить данные или кэш
         - если работает анимация то можно ее остановить
          Но срабатывание этого метода не говорит что вью будет скрыт, можно начать делать свайп для скрытия экрана и опустить экран обратно, но данный метод уже вызовется
         */
    }
    
    // Вызывается после скрытия вью
    override func viewDidDisappear(_ animated: Bool) { // данный метод вызывается по факту закрытия вью
        super.viewDidDisappear(animated)
        printMessage()
    }
}

extension UIViewController {
    func printMessage(function: String = #function) {
        print("\(title ?? ""): \(function)")
         // Этот метод отображает какой метод был вызван и из какого вью контроллера
        // здесь мы передаем фрагму редактора #function которая определяет функцию из которой вызывается метод, можно просто в любом методе написать print #function и когда этот метод будет вызван мы увидем на консоли какой метод был вызван.
    }
}
